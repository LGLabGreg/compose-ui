---
description: When creating the compose ui Table component
alwaysApply: false
---

# Compose UI Table Component - Implementation Plan

## Overview

A fully-featured, accessible Table component built on native HTML table elements with a consolidated `useTable` hook that handles formatting, sorting, pagination, search, and filtering through a single API.

### Design Principles

- **Composition over configuration** — Presentational primitives + logic hook
- **Single source of truth** — All table state managed by `useTable` hook
- **Progressive enhancement** — Each feature is opt-in via config
- **Type safety** — Full TypeScript inference from data shape
- **AI-friendly** — Declarative column config that's easy to generate
- **No third-party dependencies** — Pure React implementation

---

## Component Anatomy

### Presentational Primitives (styled HTML)

| Component      | HTML Element | Purpose                          |
| -------------- | ------------ | -------------------------------- |
| `Table`        | `<table>`    | Root container with variants     |
| `TableHeader`  | `<thead>`    | Header row wrapper               |
| `TableBody`    | `<tbody>`    | Body rows wrapper                |
| `TableFooter`  | `<tfoot>`    | Footer/summary row wrapper       |
| `TableRow`     | `<tr>`       | Row with hover/selected states   |
| `TableHead`    | `<th>`       | Header cell with sort affordance |
| `TableCell`    | `<td>`       | Data cell with alignment         |
| `TableCaption` | `<caption>`  | Accessible table description     |

### Interactive Components

| Component         | Purpose                            |
| ----------------- | ---------------------------------- |
| `TableSearch`     | Controlled search input            |
| `TablePagination` | Page controls + page size selector |

### Logic Hook

| Hook       | Purpose                                        |
| ---------- | ---------------------------------------------- |
| `useTable` | Consolidated state management for all features |

---

## Implementation Phases

### Phase 1: Base Primitives + Column Formatting

### Phase 2: Pagination

### Phase 3: Sorting

### Phase 4: Search

### Phase 5: Filters

### Phase 6: Row Selection (Future)

---

## Phase 1: Base Primitives + Column Formatting

### Goals

- Create all presentational table primitives
- Implement basic `useTable` hook with column definitions
- Support `format`, `cell`, `align`, and className props

### Type Definitions

```tsx
// types.ts

export type Alignment = 'left' | 'center' | 'right'

export interface ColumnDef<T, K extends keyof T = keyof T> {
  /** Column header text */
  header: string

  /** Simple value formatter — returns string */
  format?: (value: T[K], row: T) => string

  /** Full cell renderer — returns ReactNode, overrides format */
  cell?: (value: T[K], row: T) => ReactNode

  /** Cell text alignment */
  align?: Alignment

  /** Additional class for header cell */
  headerClassName?: string

  /** Additional class for body cells */
  cellClassName?: string

  /** Column width (CSS value) */
  width?: string | number
}

export type ColumnsConfig<T> = {
  [K in keyof T]?: ColumnDef<T, K>
}

export interface UseTableOptions<T> {
  /** Column definitions with formatting */
  columns: ColumnsConfig<T>
}

export interface ProcessedColumn<T> {
  key: keyof T
  header: string
  headerClassName: string | undefined
  cellClassName: string | undefined
  width: string | number | undefined
  renderCell: (row: T) => ReactNode
}

export interface UseTableReturn<T> {
  /** Processed columns with render helpers */
  columns: ProcessedColumn<T>[]

  /** Data rows (all data in Phase 1) */
  rows: T[]

  /** Total number of items */
  totalItems: number
}
```

### Component APIs

#### Table

```tsx
interface TableProps extends React.ComponentPropsWithoutRef<'table'> {
  /** Visual variant */
  variant?: 'default' | 'striped' | 'bordered'
}

// Usage
;<Table variant='striped'>{children}</Table>
```

#### TableHeader

```tsx
interface TableHeaderProps extends React.ComponentPropsWithoutRef<'thead'> {}

// Usage
;<TableHeader>
  <TableRow>...</TableRow>
</TableHeader>
```

#### TableBody

```tsx
interface TableBodyProps extends React.ComponentPropsWithoutRef<'tbody'> {}

// Usage
;<TableBody>
  {rows.map((row) => (
    <TableRow key={row.id}>...</TableRow>
  ))}
</TableBody>
```

#### TableFooter

```tsx
interface TableFooterProps extends React.ComponentPropsWithoutRef<'tfoot'> {}

// Usage
;<TableFooter>
  <TableRow>...</TableRow>
</TableFooter>
```

#### TableRow

```tsx
interface TableRowProps extends React.ComponentPropsWithoutRef<'tr'> {
  /** Selected state styling */
  selected?: boolean
}

// Usage
;<TableRow selected={isSelected}>{cells}</TableRow>
```

#### TableHead

```tsx
interface TableHeadProps extends React.ComponentPropsWithoutRef<'th'> {
  /** Text alignment */
  align?: Alignment
}

// Phase 1 — sorting props added in Phase 3
// Usage
;<TableHead align='right'>Price</TableHead>
```

#### TableCell

```tsx
interface TableCellProps extends React.ComponentPropsWithoutRef<'td'> {
  /** Text alignment */
  align?: Alignment
}

// Usage
;<TableCell align='right'>$99.00</TableCell>
```

#### TableCaption

```tsx
interface TableCaptionProps extends React.ComponentPropsWithoutRef<'caption'> {
  /** Position relative to table */
  position?: 'top' | 'bottom'
}

// Usage
;<TableCaption position='bottom'>A list of recent invoices</TableCaption>
```

### useTable Hook (Phase 1)

```tsx
function useTable<T extends Record<string, unknown>>(
  data: T[],
  options: UseTableOptions<T>,
): UseTableReturn<T>
```

### Implementation Details

#### Alignment Class Mapping

```tsx
const alignmentClasses: Record<Alignment, string> = {
  left: 'text-left',
  center: 'text-center',
  right: 'text-right',
}
```

#### Column Processing

```tsx
// Inside useTable
const columns = useMemo((): ProcessedColumn<T>[] => {
  const entries = Object.entries(options.columns) as [keyof T, ColumnDef<T>][]

  return entries.map(([key, def]) => {
    const renderCell = (row: T): ReactNode => {
      const value = row[key]
      if (def.cell) return def.cell(value, row)
      if (def.format) return def.format(value, row)
      return value == null ? '' : String(value)
    }

    const alignClass = def.align ? alignmentClasses[def.align] : undefined

    return {
      key,
      header: def.header,
      headerClassName: cn(def.headerClassName, alignClass),
      cellClassName: cn(def.cellClassName, alignClass),
      width: def.width,
      renderCell,
    }
  })
}, [options.columns])
```

### Phase 1 Usage Example

```tsx
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
  useTable,
} from '@lglab/compose-ui'

const users = [
  { id: 1, name: 'Alice', email: 'alice@example.com', salary: 95000 },
  { id: 2, name: 'Bob', email: 'bob@example.com', salary: 72000 },
]

function UsersTable() {
  const table = useTable(users, {
    columns: {
      name: { header: 'Name' },
      email: { header: 'Email' },
      salary: {
        header: 'Salary',
        format: (value) => `$${value.toLocaleString()}`,
        align: 'right',
      },
    },
  })

  return (
    <Table>
      <TableHeader>
        <TableRow>
          {table.columns.map((col) => (
            <TableHead key={col.key} className={col.headerClassName}>
              {col.header}
            </TableHead>
          ))}
        </TableRow>
      </TableHeader>
      <TableBody>
        {table.rows.map((row) => (
          <TableRow key={row.id}>
            {table.columns.map((col) => (
              <TableCell key={col.key} className={col.cellClassName}>
                {col.renderCell(row)}
              </TableCell>
            ))}
          </TableRow>
        ))}
      </TableBody>
    </Table>
  )
}
```

### File Structure (Phase 1)

```
packages/compose-ui/src/
├── Table/
│   ├── index.ts              # Barrel export
│   ├── Table.tsx             # Root table component
│   ├── TableHeader.tsx
│   ├── TableBody.tsx
│   ├── TableFooter.tsx
│   ├── TableRow.tsx
│   ├── TableHead.tsx
│   ├── TableCell.tsx
│   ├── TableCaption.tsx
│   ├── useTable.ts           # Hook
│   └── types.ts              # Shared types
```

### CSS Variables

```css
/* Add to theme */
--table-header-bg: var(--color-muted);
--table-row-hover-bg: var(--color-muted / 0.5);
--table-row-selected-bg: var(--color-primary / 0.1);
--table-border-color: var(--color-border);
--table-cell-padding-x: 1rem;
--table-cell-padding-y: 0.75rem;
--table-cell-padding-x-dense: 0.5rem;
--table-cell-padding-y-dense: 0.25rem;
```

---

## Phase 2: Pagination

### Goals

- Add `TablePagination` component
- Extend `useTable` with pagination config and state
- Handle page reset when data changes

### Additional Types

```tsx
// Add to types.ts

export interface PaginationConfig {
  /** Items per page */
  pageSize: number

  /** Available page size options */
  pageSizeOptions?: number[]
}

// Extend UseTableOptions
export interface UseTableOptions<T> {
  columns: ColumnsConfig<T>

  /** Enable pagination */
  pagination?: PaginationConfig
}

// Extend UseTableReturn
export interface UseTableReturn<T> {
  columns: ProcessedColumn<T>[]
  rows: T[]
  totalItems: number

  // Pagination (present if pagination config provided)
  currentPage: number
  totalPages: number
  pageSize: number
  onPageChange: (page: number) => void
  onPageSizeChange: (size: number) => void
  pageSizeOptions: number[]
}
```

### TablePagination Component

```tsx
interface TablePaginationProps {
  /** Current active page (1-indexed) */
  currentPage: number

  /** Total number of pages */
  totalPages: number

  /** Current page size */
  pageSize: number

  /** Available page size options */
  pageSizeOptions?: number[]

  /** Callback when page changes */
  onPageChange: (page: number) => void

  /** Callback when page size changes */
  onPageSizeChange?: (size: number) => void

  /** Show first/last page buttons */
  showFirstLast?: boolean

  /** Show page size selector */
  showPageSize?: boolean

  /** Additional class name */
  className?: string
}

// Usage
;<TablePagination
  currentPage={table.currentPage}
  totalPages={table.totalPages}
  pageSize={table.pageSize}
  pageSizeOptions={table.pageSizeOptions}
  onPageChange={table.onPageChange}
  onPageSizeChange={table.onPageSizeChange}
/>
```

### useTable Updates (Phase 2)

```tsx
function useTable<T>(data: T[], options: UseTableOptions<T>) {
  // ... Phase 1 code ...

  // Pagination state
  const [currentPage, setCurrentPage] = useState(1)
  const [pageSize, setPageSize] = useState(options.pagination?.pageSize ?? 10)

  const pageSizeOptions = options.pagination?.pageSizeOptions ?? [10, 25, 50]

  // Calculate after filtering (will matter in Phase 4+)
  const totalItems = processedData.length
  const totalPages = Math.ceil(totalItems / pageSize)

  // Reset page when data shrinks
  useEffect(() => {
    if (currentPage > totalPages && totalPages > 0) {
      setCurrentPage(1)
    }
  }, [totalItems, totalPages, currentPage])

  // Slice data for current page
  const rows = useMemo(() => {
    if (!options.pagination) return processedData
    const start = (currentPage - 1) * pageSize
    return processedData.slice(start, start + pageSize)
  }, [processedData, currentPage, pageSize, options.pagination])

  // Actions
  const onPageChange = useCallback(
    (page: number) => {
      setCurrentPage(Math.max(1, Math.min(page, totalPages)))
    },
    [totalPages],
  )

  const onPageSizeChange = useCallback((size: number) => {
    setPageSize(size)
    setCurrentPage(1) // Reset to first page
  }, [])

  return {
    // ... Phase 1 return ...
    currentPage,
    totalPages,
    pageSize,
    pageSizeOptions,
    onPageChange,
    onPageSizeChange,
  }
}
```

### Phase 2 Usage Example

```tsx
function UsersTable() {
  const table = useTable(users, {
    columns: {
      name: { header: 'Name' },
      email: { header: 'Email' },
    },
    pagination: { pageSize: 10, pageSizeOptions: [10, 25, 50, 100] },
  })

  return (
    <div className='space-y-4'>
      <Table>{/* ... same as Phase 1 ... */}</Table>

      {table.totalPages > 1 && (
        <TablePagination
          currentPage={table.currentPage}
          totalPages={table.totalPages}
          pageSize={table.pageSize}
          pageSizeOptions={table.pageSizeOptions}
          onPageChange={table.onPageChange}
          onPageSizeChange={table.onPageSizeChange}
        />
      )}
    </div>
  )
}
```

### File Structure Update

```
├── Table/
│   ├── ...
│   ├── TablePagination.tsx   # NEW
```

---

## Phase 3: Sorting

### Goals

- Extend `TableHead` with sort affordance
- Extend `useTable` with sort config and state
- Implement runtime type inference for comparisons

### Additional Types

```tsx
// Add to types.ts

export type SortDirection = 'asc' | 'desc'

export interface SortConfig<T> {
  key: keyof T | null
  direction: SortDirection
}

// Extend ColumnDef
export interface ColumnDef<T, K extends keyof T = keyof T> {
  // ... Phase 1 props ...

  /** Enable sorting for this column (default: true) */
  sortable?: boolean
}

// Extend UseTableOptions
export interface UseTableOptions<T> {
  columns: ColumnsConfig<T>
  pagination?: PaginationConfig

  /** Initial sort configuration */
  sort?: {
    key: keyof T
    direction: SortDirection
  }
}

// Extend ProcessedColumn
export interface ProcessedColumn<T> {
  // ... Phase 1 props ...

  sortable: boolean
  sortDirection: SortDirection | undefined
  onSort: (() => void) | undefined
}

// Extend UseTableReturn
export interface UseTableReturn<T> {
  // ... Phase 2 props ...

  sortConfig: SortConfig<T>
  onSort: (key: keyof T) => void
}
```

### TableHead Updates

```tsx
interface TableHeadProps extends React.ComponentPropsWithoutRef<'th'> {
  align?: Alignment

  /** Whether column is sortable */
  sortable?: boolean

  /** Current sort direction (undefined = not sorted) */
  sortDirection?: SortDirection

  /** Callback when sort is requested */
  onSort?: () => void
}

// Implementation includes:
// - aria-sort attribute
// - Sort icon (chevron up/down)
// - Keyboard support (Enter/Space)
// - Focus ring
```

### Sort Comparison Logic

```tsx
// utils/sort.ts

export function inferSortType(value: unknown): 'string' | 'number' | 'date' | 'boolean' {
  if (value instanceof Date) return 'date'
  if (typeof value === 'number') return 'number'
  if (typeof value === 'boolean') return 'boolean'
  return 'string'
}

export function compareValues(a: unknown, b: unknown, direction: SortDirection): number {
  // Handle nulls — always sort to end
  if (a == null && b == null) return 0
  if (a == null) return 1
  if (b == null) return -1

  const sortType = inferSortType(a)
  let comparison = 0

  switch (sortType) {
    case 'number':
      comparison = (a as number) - (b as number)
      break
    case 'date':
      comparison = (a as Date).getTime() - (b as Date).getTime()
      break
    case 'boolean':
      comparison = a === b ? 0 : a ? -1 : 1
      break
    case 'string':
    default:
      comparison = String(a).localeCompare(String(b))
      break
  }

  return direction === 'asc' ? comparison : -comparison
}
```

### useTable Updates (Phase 3)

```tsx
function useTable<T>(data: T[], options: UseTableOptions<T>) {
  // ... Phase 2 code ...

  // Sort state
  const [sortConfig, setSortConfig] = useState<SortConfig<T>>({
    key: options.sort?.key ?? null,
    direction: options.sort?.direction ?? 'asc',
  })

  // Process data: sort → paginate
  const processedData = useMemo(() => {
    let result = [...data]

    // Sort
    if (sortConfig.key) {
      const key = sortConfig.key
      result.sort((a, b) => compareValues(a[key], b[key], sortConfig.direction))
    }

    return result
  }, [data, sortConfig])

  // Build columns with sort props
  const columns = useMemo((): ProcessedColumn<T>[] => {
    return entries.map(([key, def]) => {
      const isSortable = def.sortable !== false
      const isSorted = sortConfig.key === key

      return {
        // ... Phase 1 props ...
        sortable: isSortable,
        sortDirection: isSorted ? sortConfig.direction : undefined,
        onSort: isSortable ? () => onSort(key) : undefined,
      }
    })
  }, [options.columns, sortConfig, onSort])

  // Sort action
  const onSort = useCallback((key: keyof T) => {
    setSortConfig((prev) => ({
      key,
      direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc',
    }))
  }, [])

  return {
    // ... Phase 2 return ...
    sortConfig,
    onSort,
  }
}
```

### Phase 3 Usage Example

```tsx
function UsersTable() {
  const table = useTable(users, {
    columns: {
      name: { header: 'Name' },
      email: { header: 'Email' },
      salary: {
        header: 'Salary',
        format: (value) => `$${value.toLocaleString()}`,
        align: 'right',
      },
      role: {
        header: 'Role',
        sortable: false, // Disable sorting
      },
    },
    sort: { key: 'name', direction: 'asc' },
    pagination: { pageSize: 10 },
  })

  return (
    <Table>
      <TableHeader>
        <TableRow>
          {table.columns.map((col) => (
            <TableHead
              key={col.key}
              className={col.headerClassName}
              sortable={col.sortable}
              sortDirection={col.sortDirection}
              onSort={col.onSort}
            >
              {col.header}
            </TableHead>
          ))}
        </TableRow>
      </TableHeader>
      {/* ... body ... */}
    </Table>
  )
}
```

---

## Phase 4: Search

### Goals

- Add `TableSearch` component
- Extend `useTable` with search config and state
- Implement debounced filtering

### Additional Types

```tsx
// Add to types.ts

export interface SearchConfig<T> {
  /** Keys to search across */
  keys: (keyof T)[]

  /** Debounce delay in ms (default: 150) */
  debounceMs?: number
}

// Extend UseTableOptions
export interface UseTableOptions<T> {
  columns: ColumnsConfig<T>
  pagination?: PaginationConfig
  sort?: { key: keyof T; direction: SortDirection }

  /** Enable search */
  search?: SearchConfig<T>
}

// Extend UseTableReturn
export interface UseTableReturn<T> {
  // ... Phase 3 props ...

  searchTerm: string
  onSearchChange: (term: string) => void
  clearSearch: () => void
  isSearching: boolean // True during debounce
}
```

### TableSearch Component

```tsx
interface TableSearchProps extends Omit<InputProps, 'onChange'> {
  /** Current search value */
  value: string

  /** Callback when search changes */
  onChange: (value: string) => void

  /** Show loading indicator during debounce */
  isSearching?: boolean
}

// Usage
;<TableSearch
  value={table.searchTerm}
  onChange={table.onSearchChange}
  placeholder='Search...'
/>
```

### useTable Updates (Phase 4)

```tsx
function useTable<T>(data: T[], options: UseTableOptions<T>) {
  // ... Phase 3 code ...

  // Search state
  const [searchTerm, setSearchTerm] = useState('')
  const [debouncedTerm, setDebouncedTerm] = useState('')

  // Debounce
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedTerm(searchTerm)
    }, options.search?.debounceMs ?? 150)
    return () => clearTimeout(timer)
  }, [searchTerm, options.search?.debounceMs])

  // Process data: search → sort → paginate
  const processedData = useMemo(() => {
    let result = [...data]

    // Search
    if (options.search && debouncedTerm.trim()) {
      const lowerSearch = debouncedTerm.toLowerCase()
      result = result.filter((item) =>
        options.search!.keys.some((key) => {
          const value = item[key]
          return value != null && String(value).toLowerCase().includes(lowerSearch)
        }),
      )
    }

    // Sort
    if (sortConfig.key) {
      const key = sortConfig.key
      result.sort((a, b) => compareValues(a[key], b[key], sortConfig.direction))
    }

    return result
  }, [data, debouncedTerm, sortConfig, options.search])

  // Search actions
  const onSearchChange = useCallback((term: string) => {
    setSearchTerm(term)
    setCurrentPage(1) // Reset pagination
  }, [])

  const clearSearch = useCallback(() => {
    setSearchTerm('')
    setCurrentPage(1)
  }, [])

  const isSearching = searchTerm !== debouncedTerm

  return {
    // ... Phase 3 return ...
    searchTerm,
    onSearchChange,
    clearSearch,
    isSearching,
  }
}
```

### Phase 4 Usage Example

```tsx
function UsersTable() {
  const table = useTable(users, {
    columns: {
      name: { header: 'Name' },
      email: { header: 'Email' },
    },
    search: { keys: ['name', 'email'] },
    sort: { key: 'name', direction: 'asc' },
    pagination: { pageSize: 10 },
  })

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <TableSearch
          value={table.searchTerm}
          onChange={table.onSearchChange}
          placeholder="Search users..."
          className="max-w-sm"
        />
        <span className="text-sm text-muted-foreground">
          {table.totalItems} result{table.totalItems !== 1 && 's'}
        </span>
      </div>

      <Table>
        {/* ... */}
      </Table>

      <TablePagination {...} />
    </div>
  )
}
```

### File Structure Update

```
├── Table/
│   ├── ...
│   ├── TableSearch.tsx       # NEW
```

---

## Phase 5: Filters

### Goals

- Extend `useTable` with filter config and state
- Support select, multiSelect, and boolean filter types
- Provide helpers for building filter UI

### Additional Types

```tsx
// Add to types.ts

export type FilterType = 'select' | 'multiSelect' | 'boolean'

export interface FilterConfig {
  /** Filter input type */
  type?: FilterType // Default: 'select'

  /** Available options (auto-derived if omitted) */
  options?: string[]
}

export type FiltersConfig<T> = {
  [K in keyof T]?: FilterConfig
}

// Extend UseTableOptions
export interface UseTableOptions<T> {
  columns: ColumnsConfig<T>
  pagination?: PaginationConfig
  sort?: { key: keyof T; direction: SortDirection }
  search?: SearchConfig<T>

  /** Enable column filters */
  filters?: FiltersConfig<T>
}

// Extend UseTableReturn
export interface UseTableReturn<T> {
  // ... Phase 4 props ...

  /** Get current filter value for a key */
  getFilterValue: <K extends keyof T>(key: K) => T[K] | T[K][] | null

  /** Set filter value for a key */
  setFilterValue: <K extends keyof T>(key: K, value: T[K] | T[K][] | null) => void

  /** Clear all filters */
  clearFilters: () => void

  /** Get available options for a filter key */
  getFilterOptions: (key: keyof T) => string[]

  /** Number of active filters */
  activeFilterCount: number
}
```

### useTable Updates (Phase 5)

```tsx
function useTable<T>(data: T[], options: UseTableOptions<T>) {
  // ... Phase 4 code ...

  // Filter state
  const [filterValues, setFilterValues] = useState<Partial<Record<keyof T, unknown>>>({})

  // Process data: filter → search → sort → paginate
  const processedData = useMemo(() => {
    let result = [...data]

    // Filter
    if (options.filters) {
      Object.entries(filterValues).forEach(([key, value]) => {
        if (value == null) return

        const config = options.filters![key as keyof T]
        if (!config) return

        const filterType = config.type ?? 'select'

        if (filterType === 'select') {
          result = result.filter((item) => item[key as keyof T] === value)
        } else if (filterType === 'multiSelect' && Array.isArray(value)) {
          result = result.filter((item) =>
            (value as unknown[]).includes(item[key as keyof T]),
          )
        } else if (filterType === 'boolean') {
          result = result.filter((item) => Boolean(item[key as keyof T]) === value)
        }
      })
    }

    // Search (Phase 4)
    // Sort (Phase 3)

    return result
  }, [data, filterValues, debouncedTerm, sortConfig, options])

  // Filter helpers
  const getFilterValue = useCallback(
    <K extends keyof T>(key: K) => filterValues[key] as T[K] | null,
    [filterValues],
  )

  const setFilterValue = useCallback(<K extends keyof T>(key: K, value: T[K] | null) => {
    setFilterValues((prev) => ({ ...prev, [key]: value }))
    setCurrentPage(1)
  }, [])

  const clearFilters = useCallback(() => {
    setFilterValues({})
    setCurrentPage(1)
  }, [])

  const getFilterOptions = useCallback(
    (key: keyof T): string[] => {
      const config = options.filters?.[key]
      if (!config) return []

      // Use provided options
      if (config.options) return config.options

      // Auto-derive from data
      const unique = new Set(data.map((item) => String(item[key])))
      return Array.from(unique).sort()
    },
    [options.filters, data],
  )

  const activeFilterCount = useMemo(
    () => Object.values(filterValues).filter((v) => v != null).length,
    [filterValues],
  )

  return {
    // ... Phase 4 return ...
    getFilterValue,
    setFilterValue,
    clearFilters,
    getFilterOptions,
    activeFilterCount,
  }
}
```

### Phase 5 Usage Example

```tsx
function UsersTable() {
  const table = useTable(users, {
    columns: {
      name: { header: 'Name' },
      email: { header: 'Email' },
      role: { header: 'Role' },
      status: { header: 'Status' },
    },
    search: { keys: ['name', 'email'] },
    sort: { key: 'name', direction: 'asc' },
    pagination: { pageSize: 10 },
    filters: {
      role: { options: ['Admin', 'User', 'Editor'] },
      status: { type: 'boolean' },
    },
  })

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-4">
        <TableSearch
          value={table.searchTerm}
          onChange={table.onSearchChange}
          placeholder="Search..."
        />

        <Select
          value={table.getFilterValue('role') ?? ''}
          onValueChange={(v) => table.setFilterValue('role', v || null)}
        >
          <SelectTrigger className="w-40">
            <SelectValue placeholder="All roles" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="">All roles</SelectItem>
            {table.getFilterOptions('role').map((opt) => (
              <SelectItem key={opt} value={opt}>{opt}</SelectItem>
            ))}
          </SelectContent>
        </Select>

        {table.activeFilterCount > 0 && (
          <Button variant="ghost" size="sm" onClick={table.clearFilters}>
            Clear ({table.activeFilterCount})
          </Button>
        )}
      </div>

      <Table>
        {/* ... */}
      </Table>

      <TablePagination {...} />
    </div>
  )
}
```

---

## Data Processing Pipeline

The final data processing order in `useTable`:

```
raw data
    ↓
┌───────────┐
│  Filter   │  Remove rows not matching active filters
└───────────┘
    ↓
┌───────────┐
│  Search   │  Remove rows not matching search term
└───────────┘
    ↓
┌───────────┐
│   Sort    │  Reorder rows by sort config
└───────────┘
    ↓
┌───────────┐
│ Paginate  │  Slice to current page
└───────────┘
    ↓
rows (returned to component)
```

---

## Complete Final API

### useTable Options

```tsx
interface UseTableOptions<T> {
  columns: {
    [K in keyof T]?: {
      header: string
      format?: (value: T[K], row: T) => string
      cell?: (value: T[K], row: T) => ReactNode
      align?: 'left' | 'center' | 'right'
      headerClassName?: string
      cellClassName?: string
      width?: string | number
      sortable?: boolean
    }
  }

  pagination?: {
    pageSize: number
    pageSizeOptions?: number[]
  }

  sort?: {
    key: keyof T
    direction: 'asc' | 'desc'
  }

  search?: {
    keys: (keyof T)[]
    debounceMs?: number
  }

  filters?: {
    [K in keyof T]?: {
      type?: 'select' | 'multiSelect' | 'boolean'
      options?: string[]
    }
  }
}
```

### useTable Return

```tsx
interface UseTableReturn<T> {
  // Columns
  columns: ProcessedColumn<T>[]

  // Data
  rows: T[]
  totalItems: number

  // Pagination
  currentPage: number
  totalPages: number
  pageSize: number
  pageSizeOptions: number[]
  onPageChange: (page: number) => void
  onPageSizeChange: (size: number) => void

  // Sort
  sortConfig: { key: keyof T | null; direction: 'asc' | 'desc' }
  onSort: (key: keyof T) => void

  // Search
  searchTerm: string
  onSearchChange: (term: string) => void
  clearSearch: () => void
  isSearching: boolean

  // Filters
  getFilterValue: <K extends keyof T>(key: K) => T[K] | T[K][] | null
  setFilterValue: <K extends keyof T>(key: K, value: T[K] | T[K][] | null) => void
  clearFilters: () => void
  getFilterOptions: (key: keyof T) => string[]
  activeFilterCount: number
}
```

---

## Testing Strategy

### Unit Tests (per component)

| Component        | Tests                                                          |
| ---------------- | -------------------------------------------------------------- |
| Table primitives | Renders correct HTML elements, forwards refs, applies variants |
| TableHead        | Sort icon visibility, aria-sort, keyboard activation           |
| TablePagination  | Page navigation, boundary conditions, page size change         |
| TableSearch      | Input binding, clear button                                    |

### useTable Hook Tests

| Feature    | Tests                                                             |
| ---------- | ----------------------------------------------------------------- |
| Columns    | Processes all columns, applies formatting, handles missing values |
| Pagination | Correct slicing, page reset on data change, boundary conditions   |
| Sort       | All type comparisons, null handling, direction toggle             |
| Search     | Case insensitive, multi-key, debounce, page reset                 |
| Filters    | Select match, multiSelect match, boolean match, clear             |

### Integration Tests

- Full table with all features enabled
- Empty state handling
- Large dataset performance

---

## Future Considerations (Phase 6+)

### Row Selection

```tsx
// Potential API
const table = useTable(users, {
  // ...
  selection: {
    mode: 'single' | 'multiple',
    onSelectionChange?: (selectedIds: (string | number)[]) => void,
  },
})

// Returns
table.selectedIds: (string | number)[]
table.isSelected: (id: string | number) => boolean
table.toggleSelected: (id: string | number) => void
table.toggleAllSelected: () => void
table.clearSelection: () => void
```

### Column Visibility

```tsx
// Potential API
const table = useTable(users, {
  columns: {
    email: { header: 'Email', visible: false }, // Initially hidden
  },
})

// Returns
table.visibleColumns: ProcessedColumn<T>[]
table.setColumnVisibility: (key: keyof T, visible: boolean) => void
```

### Server-Side Mode

```tsx
// Potential API
const table = useTable([], {
  serverSide: true,
  totalItems: serverTotal,
  onStateChange: (state) => {
    // state includes: page, pageSize, sort, search, filters
    // Consumer fetches data and updates
  },
})
```
